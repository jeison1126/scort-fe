import { Pipe } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "./ngx-mask-applier.service";
export class NgxMaskPipe {
    //TODO(inepipepnko): need use inject fn but problem with error in test
    constructor(_maskService) {
        this._maskService = _maskService;
    }
    transform(value, mask, thousandSeparator = null) {
        if (!value && typeof value !== 'number') {
            return '';
        }
        if (thousandSeparator) {
            this._maskService.thousandSeparator = thousandSeparator;
        }
        if (typeof mask === 'string') {
            return this._maskService.applyMask(`${value}`, mask);
        }
        return this._maskService.applyMaskWithPattern(`${value}`, mask);
    }
}
NgxMaskPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgxMaskPipe, deps: [{ token: i1.NgxMaskApplierService }], target: i0.ɵɵFactoryTarget.Pipe });
NgxMaskPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.0.4", ngImport: i0, type: NgxMaskPipe, isStandalone: true, name: "mask" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgxMaskPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'mask',
                    pure: true,
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i1.NgxMaskApplierService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LW1hc2sucGlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1tYXNrLWxpYi9zcmMvbGliL25neC1tYXNrLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7OztBQVVwRCxNQUFNLE9BQU8sV0FBVztJQUNwQixzRUFBc0U7SUFDdEUsWUFBb0MsWUFBbUM7UUFBbkMsaUJBQVksR0FBWixZQUFZLENBQXVCO0lBQUcsQ0FBQztJQUVwRSxTQUFTLENBQ1osS0FBc0IsRUFDdEIsSUFBNEMsRUFDNUMsb0JBQW1DLElBQUk7UUFFdkMsSUFBSSxDQUFDLEtBQUssSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDckMsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNELElBQUksaUJBQWlCLEVBQUU7WUFDbkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQztTQUMzRDtRQUNELElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQzFCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsR0FBRyxLQUFLLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUN4RDtRQUNELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLEtBQUssRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3BFLENBQUM7O3dHQW5CUSxXQUFXO3NHQUFYLFdBQVc7MkZBQVgsV0FBVztrQkFMdkIsSUFBSTttQkFBQztvQkFDRixJQUFJLEVBQUUsTUFBTTtvQkFDWixJQUFJLEVBQUUsSUFBSTtvQkFDVixVQUFVLEVBQUUsSUFBSTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE5neE1hc2tBcHBsaWVyU2VydmljZSB9IGZyb20gJy4vbmd4LW1hc2stYXBwbGllci5zZXJ2aWNlJztcbmltcG9ydCB7IElDb25maWcgfSBmcm9tICcuL25neC1tYXNrLmNvbmZpZyc7XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAnbWFzaycsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxufSlcbmV4cG9ydCBjbGFzcyBOZ3hNYXNrUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIC8vVE9ETyhpbmVwaXBlcG5rbyk6IG5lZWQgdXNlIGluamVjdCBmbiBidXQgcHJvYmxlbSB3aXRoIGVycm9yIGluIHRlc3RcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBfbWFza1NlcnZpY2U6IE5neE1hc2tBcHBsaWVyU2VydmljZSkge31cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIsXG4gICAgICAgIG1hc2s6IHN0cmluZyB8IFtzdHJpbmcsIElDb25maWdbJ3BhdHRlcm5zJ11dLFxuICAgICAgICB0aG91c2FuZFNlcGFyYXRvcjogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICApOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhvdXNhbmRTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX21hc2tTZXJ2aWNlLnRob3VzYW5kU2VwYXJhdG9yID0gdGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtYXNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hc2tTZXJ2aWNlLmFwcGx5TWFzayhgJHt2YWx1ZX1gLCBtYXNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWFza1NlcnZpY2UuYXBwbHlNYXNrV2l0aFBhdHRlcm4oYCR7dmFsdWV9YCwgbWFzayk7XG4gICAgfVxufVxuIl19